{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to WaterFlow\n\n\nWaterFlow is a non-magical / easy to understand / JDK8 framework for use with \nSimple Workflow Service\n\n\nPhilosophy\n\n\n\n\nThe framework is deeply routed in the original implementation of \nSWiFt\n which is a great example of achieving a very usable and simple SWF framework.\n\n\n\n\nSWF is a great AWS service allowing the ability to implement distributed, asynchronous applications as workflows. The interesting part of SWF is that its easy to integrate with various \nin-house\n solutions, since the various actors necessary to operate with the service can operate onsite (only execution history is stored in the \"cloud\")\n\n\nThe difficulty lies in writing robust, easy and composable workflows. SWF offers the \nFlow Framework\n which is a is a collection of convenience libraries that make it faster and easier to build applications with Amazon Simple Workflow on the JVM. The problem we've found however is that there is just too much \ndarn magic\n !\n\n\nNo magic - WYSIWYG\n\n\nA key tenant to the \nWaterFlow\n framework is the removal of much of the magic present in competing frameworks, while still providing many of the same features. Many times this might lead to code that is \nslightly\n more verbose, however you are presented with a \nWYSIWYG\n experience.\n\n\nImmutability\n\n\nThe \nWateFlow\n framework makes, \nheavy\n use of the \nImmutables\n library, and so should you! Since typically you might run multiple JVM instances of a particular actor (deciders \n activity workers) and each JVM might run several threads - its much easier to think about the underlying primitives knowing they are \nimmutable\n.\n\n\nSimple Deciders\n\n\nDeciders are the actors that coordinate the logic of the current workflow by scheduling various actions - such as Activities. The concept of scheduling a future asyncrhonous computation and writing it in a very functional manner is well understood through various \nAyncrhonous Programming Patterns\n. \nWaterFlow\n leverages well known standard interfaces - \nCompletionStage\n - to help making complicated deciders.\n\n\nFunctional / JDK8\n\n\nBy embracing the \nJDK8\n, much of the code is written in a very functional manner.\n\n\nTested\n\n\nThe framework includes many \nunit\n and \nintegration\n tests. These tests serve as great self-documentation - in addition to this site.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-waterflow", 
            "text": "WaterFlow is a non-magical / easy to understand / JDK8 framework for use with  Simple Workflow Service", 
            "title": "Welcome to WaterFlow"
        }, 
        {
            "location": "/#philosophy", 
            "text": "The framework is deeply routed in the original implementation of  SWiFt  which is a great example of achieving a very usable and simple SWF framework.   SWF is a great AWS service allowing the ability to implement distributed, asynchronous applications as workflows. The interesting part of SWF is that its easy to integrate with various  in-house  solutions, since the various actors necessary to operate with the service can operate onsite (only execution history is stored in the \"cloud\")  The difficulty lies in writing robust, easy and composable workflows. SWF offers the  Flow Framework  which is a is a collection of convenience libraries that make it faster and easier to build applications with Amazon Simple Workflow on the JVM. The problem we've found however is that there is just too much  darn magic  !", 
            "title": "Philosophy"
        }, 
        {
            "location": "/#no-magic-wysiwyg", 
            "text": "A key tenant to the  WaterFlow  framework is the removal of much of the magic present in competing frameworks, while still providing many of the same features. Many times this might lead to code that is  slightly  more verbose, however you are presented with a  WYSIWYG  experience.", 
            "title": "No magic - WYSIWYG"
        }, 
        {
            "location": "/#immutability", 
            "text": "The  WateFlow  framework makes,  heavy  use of the  Immutables  library, and so should you! Since typically you might run multiple JVM instances of a particular actor (deciders   activity workers) and each JVM might run several threads - its much easier to think about the underlying primitives knowing they are  immutable .", 
            "title": "Immutability"
        }, 
        {
            "location": "/#simple-deciders", 
            "text": "Deciders are the actors that coordinate the logic of the current workflow by scheduling various actions - such as Activities. The concept of scheduling a future asyncrhonous computation and writing it in a very functional manner is well understood through various  Ayncrhonous Programming Patterns .  WaterFlow  leverages well known standard interfaces -  CompletionStage  - to help making complicated deciders.", 
            "title": "Simple Deciders"
        }, 
        {
            "location": "/#functional-jdk8", 
            "text": "By embracing the  JDK8 , much of the code is written in a very functional manner.", 
            "title": "Functional / JDK8"
        }, 
        {
            "location": "/#tested", 
            "text": "The framework includes many  unit  and  integration  tests. These tests serve as great self-documentation - in addition to this site.", 
            "title": "Tested"
        }, 
        {
            "location": "/user-guide/getting-started/", 
            "text": "Getting Started\n\n\nThe following tutorial will walk you through a very brief introduction to installing \nWaterFlow\n and writing your first\n\nHelloWorldWorkflow\n.\n\n\nFor more advanced workflows and additional information consult the user-guide.\n\n\nRequirements\n\n\n\n\nJava 1.8+\n\n\nActive \nAmazon Web Services\n account\n\n\nAWS credentials must have full access to the SWF service\n\n\n\n\n\n\nUnderstanding of Amazon Simple Workflow concepts and the Amazon AWS SDK for Java\n\n\n\n\nInstallation\n\n\ndependency\n\n    \ngroupId\ncom.github.fzakaria\n/groupId\n\n    \nartifactId\nWaterFlow\n/artifactId\n\n    \nversion\n1.0-SNAPSHOT\n/version\n\n\n/dependency\n\n\n\n\n\nHelloWorld\nWorkFlow\n\n\nThe following is a short tutorial on building a Maven application using \nWaterFlow\n. It is a very high level overview and additional information can be found in accompanying sections of the user-guide.\n\n\nYou can find the code listed below on \nGitHub\n\n\nSetup\n\n\nWe will assume a \nmaven\n setup, however the only difference is transitioning the \npom.xml\n to the build tool of your choice.\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nproject xmlns=\nhttp://maven.apache.org/POM/4.0.0\n\n         xmlns:xsi=\nhttp://www.w3.org/2001/XMLSchema-instance\n\n         xsi:schemaLocation=\nhttp://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\n\n    \nmodelVersion\n4.0.0\n/modelVersion\n\n\n    \ngroupId\nFILL ME IN/groupId\n\n    \nartifactId\nFILL ME IN/artifactId\n\n    \nversion\n1.0-SNAPSHOT\n/version\n\n\n    \nproperties\n\n        \nmaven.compiler.source\n1.8\n/maven.compiler.source\n\n        \nmaven.compiler.target\n1.8\n/maven.compiler.target\n\n        \nimmutables.version\n2.1.11\n/immutables.version\n\n    \n/properties\n\n\n    \ndependencies\n\n        \ndependency\n\n            \ngroupId\norg.immutables\n/groupId\n\n            \nartifactId\nvalue\n/artifactId\n\n            \nversion\n${immutables.version}\n/version\n\n            \nscope\nprovided\n/scope\n\n        \n/dependency\n\n\n        \ndependency\n\n            \ngroupId\ncom.github.fzakaria\n/groupId\n\n            \nartifactId\nWaterFlow\n/artifactId\n\n            \nversion\n1.0-SNAPSHOT\n/version\n\n        \n/dependency\n\n\n        \ndependency\n\n            \ngroupId\nch.qos.logback\n/groupId\n\n            \nartifactId\nlogback-classic\n/artifactId\n\n            \nversion\n1.1.5\n/version\n\n            \nscope\nruntime\n/scope\n\n        \n/dependency\n\n    \n/dependencies\n\n\n/project\n\n\n\n/project\n\n\n\n\n\nActivities\n\n\nThe bread and butter of actions in SWF are the \nActivityTasks\n, which represent a unit of asyncrhonous work. Activities can exist in any class that subclasses \nActivities\n and annotated with \nActivityMethod\n\n\npublic class ExampleActivities extends Activities {\n\n    @ActivityMethod(name = \nHello World\n, version = \n1.0\n)\n    public String helloWorld(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException(\nYou must provide a non null name!\n);\n        }\n        return String.format(\nHello World %s\n, name);\n    }\n\n}\n\n\n\n\nIn the example above, we've created a very simple \nActivityTask\n which given an input string, appends it to a \nHello World\n message. The example above is working solely with input/output of \nString\n however you are not limited to that! We will see in the following documentation that thanks to the \nDataConverter\n we can pass arbitrary complex types to/from our Activities.\n\n\nWorkflow\n\n\nThe workflow class in the framework represents the \nDecider\n. Through the interface \npublic CompletionStage decide(DecisionContext decisionContext)\n the Workflow can orchestrate the future actions that need to occur for the workflow given the previous history.\n\n\nThe example below is a simple example of implementing the Workflow interface. Each workflow has an associated name and version which is important when decided which instance the decider needs to find. As you can see in the \ndecide\n method, orchestrating future tasks is as simple as using the JDK8 interface for \nCompletionStage\n.\n\n\n@Value.Immutable\npublic class HelloWorldWorkflow extends Workflow\nString,String\n {\n\n    @Override\n    public Name name() {\n        return Name.of(\nHello World\n);\n    }\n\n    @Override\n    public Version version() {\n        return Version.of(\n1.0\n);\n    }\n\n    @Override\n    public TypeToken\nString\n inputType() {\n        return TypeToken.of(String.class);\n    }\n\n    @Override\n    public TypeToken\nString\n outputType() {\n        return TypeToken.of(String.class);\n    }\n\n    @Override\n    public DataConverter dataConverter() {\n        return ImmutableJacksonDataConverter.builder().build();\n    }\n\n    final StringActivityAction step1 = StringActivityAction.builder().actionId(ActionId.of(\nstep1\n))\n            .name(Name.of(\nHello World\n)).version(Version.of(\n1.0\n)).workflow(this).build();\n\n    @Override\n    public CompletionStage decide(DecisionContext decisionContext) {\n        CompletionStage\nString\n input = workflowInput(decisionContext.events());\n\n        return input.thenCompose(i -\n step1.withInput(i).decide(decisionContext));\n\n    }\n\n    //Run me to submit this workflow!\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Config config = new Config();\n        HelloWorldWorkflow workflow = ImmutableHelloWorldWorkflow.builder()\n                .description(Description.of(\nStarting my first workflow!\n)).build();\n        config.submit(workflow, \nJane Doe\n);\n    }\n}\n\n\n\n\nWe've provided a helpful \nmain\n method that you can launch that will submit a new instance of this workflow!\n\n\nActors - Deciders and Activity Workers\n\n\nYou get to decide the composition of the actors. You can scale the deciders and acivity workers seperately and arrange how each one is configured when polling a particular \nTaskList\n or \nDomain\n. For the purposes of this example, we demonstrate a basic setup that initiates both \nActivity Workers\n and \nDeciders\n as separate threads on the same JVM.\n\n\npublic class ActivityDecisionPollerPool {\n\n    protected static final Logger log = LoggerFactory.getLogger(ActivityDecisionPollerPool.class);\n\n    private final Config config = new Config();\n\n    private final  ActivityPollerPool activityPollerPool =\n            ImmutableActivityPollerPool.builder().domain(config.domain)\n                .taskList(config.taskListName)\n                .service(new ScheduledThreadPoolExecutor(config.numberOfWorkers))\n                .swf(config.swf)\n                .dataConverter(config.dataConverter)\n                .addActivities(new HelloWorldActivities()).build();\n\n    private final  DecisionPollerPool decisionPollerPool =\n            ImmutableDecisionPollerPool.builder().domain(config.domain)\n                    .taskList(config.taskListName)\n                    .service(new ScheduledThreadPoolExecutor(config.numberOfWorkers))\n                    .swf(config.swf)\n                    .dataConverter(config.dataConverter)\n                    .workflows(Lists.newArrayList(new HelloWorldWorkflow())).build();\n\n\n    public void start() {\n        activityPollerPool.start();\n        decisionPollerPool.start();\n    }\n\n    public void stop() {\n        activityPollerPool.stop();\n        decisionPollerPool.stop();\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        ActivityDecisionPollerPool activityAndDecisionPollerPool =\n                new ActivityDecisionPollerPool();\n\n        activityAndDecisionPollerPool.start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                log.info(\nShutting down pool and exiting.\n);\n                activityAndDecisionPollerPool.stop();\n            }\n        });\n        log.info(\nactivity pollers started:\n);\n    }\n}\n\n\n\n\nFor the purposes of this demonstrates, the configuration is hard configured in a POJO. However not much is needed to change the \nConfig\n class to something that is wired by your favourite Dependency Injection framework (i.e. Guice or Spring)\n\n\n\npublic class Config {\n\n    public final Domain domain = Domain.of(\nswift\n);\n\n    public final TaskListName taskListName = SwfConstants.DEFAULT_TASK_LIST;\n\n    public final Integer numberOfWorkers = 2;\n\n    public final DataConverter dataConverter = ImmutableJacksonDataConverter.builder().build();\n\n    //SWF holds the connection for 60 seconds to see if a decision is available\n    final Duration DEFAULT_CONNECTION_TIMEOUT = Duration.ofSeconds(60);\n    final Duration DEFAULT_SOCKET_TIMEOUT = DEFAULT_CONNECTION_TIMEOUT.plusSeconds(10);\n    public final AmazonSimpleWorkflow swf =  new AmazonSimpleWorkflowClient(new DefaultAWSCredentialsProviderChain(),\n            new ClientConfiguration().withConnectionTimeout((int) DEFAULT_CONNECTION_TIMEOUT.toMillis())\n                    .withSocketTimeout((int) DEFAULT_SOCKET_TIMEOUT.toMillis()));\n\n    public WorkflowExecution submit(Workflow workflow, WorkflowId workflowId, Optional\nObject\n input) {\n        Optional\nInput\n inputOptional = input.map( i -\n dataConverter.toData(i)).map(Input::of);\n\n        StartWorkflowExecutionRequest request =\n                WorkflowExecutionRequestBuilder.builder().domain(domain)\n                        .workflow(workflow).input(inputOptional)\n                        .taskList(taskListName).workflowId(workflowId).build();\n\n        Run run = swf.startWorkflowExecution(request);\n        return new WorkflowExecution().withWorkflowId(workflowId.value()).withRunId(run.getRunId());\n    }\n\n    public \nI, O\n WorkflowExecution submit(Workflow\nI,O\n workflow, I input) {\n        WorkflowId workflowId = WorkflowId.randomUniqueWorkflowId(workflow);\n        return submit(workflow, workflowId, Optional.ofNullable(input));\n    }\n}\n\n\n\n\nVerifying The Results\n\n\nWe can use the \naws cli\n tool or the SWF dashboard to verify our results!\nScroll \ndown\n to the bottom until you see the \nWorkflowExecutionCompleted\n and check out the result!\n\n\n{\n  \nevents\n: [\n    {\n      \neventId\n: 1,\n      \neventType\n: \nWorkflowExecutionStarted\n,\n      \nworkflowExecutionStartedEventAttributes\n: {\n        \ntaskList\n: {\n          \nname\n: \nDEFAULT\n\n        },\n        \nparentInitiatedEventId\n: 0,\n        \ntaskStartToCloseTimeout\n: \n60\n,\n        \nchildPolicy\n: \nTERMINATE\n,\n        \nexecutionStartToCloseTimeout\n: \n30758400\n,\n        \ninput\n: \n\\\nJane Doe\\\n,\n        \nworkflowType\n: {\n          \nversion\n: \n1.0\n,\n          \nname\n: \nHello World\n\n        }\n      },\n      \neventTimestamp\n: 1456343145.567\n    },\n    {\n      \neventId\n: 2,\n      \neventType\n: \nDecisionTaskScheduled\n,\n      \ndecisionTaskScheduledEventAttributes\n: {\n        \nstartToCloseTimeout\n: \n60\n,\n        \ntaskList\n: {\n          \nname\n: \nDEFAULT\n\n        }\n      },\n      \neventTimestamp\n: 1456343145.567\n    },\n    {\n      \neventId\n: 3,\n      \neventType\n: \nDecisionTaskStarted\n,\n      \neventTimestamp\n: 1456343145.654,\n      \ndecisionTaskStartedEventAttributes\n: {\n        \nscheduledEventId\n: 2,\n        \nidentity\n: \nDECIDER-0\n\n      }\n    },\n    {\n      \neventId\n: 4,\n      \neventType\n: \nDecisionTaskTimedOut\n,\n      \ndecisionTaskTimedOutEventAttributes\n: {\n        \nstartedEventId\n: 3,\n        \ntimeoutType\n: \nSTART_TO_CLOSE\n,\n        \nscheduledEventId\n: 2\n      },\n      \neventTimestamp\n: 1456343205.66\n    },\n    {\n      \neventId\n: 5,\n      \neventType\n: \nDecisionTaskScheduled\n,\n      \ndecisionTaskScheduledEventAttributes\n: {\n        \nstartToCloseTimeout\n: \n60\n,\n        \ntaskList\n: {\n          \nname\n: \nDEFAULT\n\n        }\n      },\n      \neventTimestamp\n: 1456343205.66\n    },\n    {\n      \neventId\n: 6,\n      \neventType\n: \nDecisionTaskStarted\n,\n      \neventTimestamp\n: 1456343205.708,\n      \ndecisionTaskStartedEventAttributes\n: {\n        \nscheduledEventId\n: 5,\n        \nidentity\n: \nDECIDER-0\n\n      }\n    },\n    {\n      \neventId\n: 7,\n      \neventType\n: \nDecisionTaskCompleted\n,\n      \ndecisionTaskCompletedEventAttributes\n: {\n        \nstartedEventId\n: 6,\n        \nscheduledEventId\n: 5\n      },\n      \neventTimestamp\n: 1456343206.078\n    },\n    {\n      \neventId\n: 8,\n      \neventType\n: \nActivityTaskScheduled\n,\n      \nactivityTaskScheduledEventAttributes\n: {\n        \ntaskList\n: {\n          \nname\n: \nDEFAULT\n\n        },\n        \nscheduleToCloseTimeout\n: \nNONE\n,\n        \nactivityType\n: {\n          \nversion\n: \n1.0\n,\n          \nname\n: \nHello World\n\n        },\n        \ndecisionTaskCompletedEventId\n: 7,\n        \nheartbeatTimeout\n: \nNONE\n,\n        \nactivityId\n: \nstep1\n,\n        \nscheduleToStartTimeout\n: \nNONE\n,\n        \nstartToCloseTimeout\n: \nNONE\n,\n        \ninput\n: \n[ \\\n[Ljava.lang.Object;\\\n, [ \\\nJane Doe\\\n ] ]\n\n      },\n      \neventTimestamp\n: 1456343206.078\n    },\n    {\n      \neventId\n: 9,\n      \neventType\n: \nActivityTaskStarted\n,\n      \neventTimestamp\n: 1456343206.185,\n      \nactivityTaskStartedEventAttributes\n: {\n        \nscheduledEventId\n: 8,\n        \nidentity\n: \nACTIVITY-0\n\n      }\n    },\n    {\n      \neventId\n: 10,\n      \neventType\n: \nActivityTaskCompleted\n,\n      \nactivityTaskCompletedEventAttributes\n: {\n        \nstartedEventId\n: 9,\n        \nscheduledEventId\n: 8,\n        \nresult\n: \n\\\nHello World Jane Doe!\\\n\n      },\n      \neventTimestamp\n: 1456343206.39\n    },\n    {\n      \neventId\n: 11,\n      \neventType\n: \nDecisionTaskScheduled\n,\n      \ndecisionTaskScheduledEventAttributes\n: {\n        \nstartToCloseTimeout\n: \n60\n,\n        \ntaskList\n: {\n          \nname\n: \nDEFAULT\n\n        }\n      },\n      \neventTimestamp\n: 1456343206.39\n    },\n    {\n      \neventId\n: 12,\n      \neventType\n: \nDecisionTaskStarted\n,\n      \neventTimestamp\n: 1456343206.45,\n      \ndecisionTaskStartedEventAttributes\n: {\n        \nscheduledEventId\n: 11,\n        \nidentity\n: \nDECIDER-1\n\n      }\n    },\n    {\n      \neventId\n: 13,\n      \neventType\n: \nDecisionTaskCompleted\n,\n      \ndecisionTaskCompletedEventAttributes\n: {\n        \nstartedEventId\n: 12,\n        \nscheduledEventId\n: 11\n      },\n      \neventTimestamp\n: 1456343206.621\n    },\n    {\n      \neventId\n: 14,\n      \neventType\n: \nWorkflowExecutionCompleted\n,\n      \nworkflowExecutionCompletedEventAttributes\n: {\n        \nresult\n: \n\\\nHello World Jane Doe!\\\n,\n        \ndecisionTaskCompletedEventId\n: 13\n      },\n      \neventTimestamp\n: 1456343206.621\n    }\n  ]\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#getting-started", 
            "text": "The following tutorial will walk you through a very brief introduction to installing  WaterFlow  and writing your first HelloWorldWorkflow .  For more advanced workflows and additional information consult the user-guide.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/user-guide/getting-started/#requirements", 
            "text": "Java 1.8+  Active  Amazon Web Services  account  AWS credentials must have full access to the SWF service    Understanding of Amazon Simple Workflow concepts and the Amazon AWS SDK for Java", 
            "title": "Requirements"
        }, 
        {
            "location": "/user-guide/getting-started/#installation", 
            "text": "dependency \n     groupId com.github.fzakaria /groupId \n     artifactId WaterFlow /artifactId \n     version 1.0-SNAPSHOT /version  /dependency", 
            "title": "Installation"
        }, 
        {
            "location": "/user-guide/getting-started/#helloworldworkflow", 
            "text": "The following is a short tutorial on building a Maven application using  WaterFlow . It is a very high level overview and additional information can be found in accompanying sections of the user-guide.  You can find the code listed below on  GitHub", 
            "title": "HelloWorldWorkFlow"
        }, 
        {
            "location": "/user-guide/getting-started/#setup", 
            "text": "We will assume a  maven  setup, however the only difference is transitioning the  pom.xml  to the build tool of your choice.  ?xml version= 1.0  encoding= UTF-8 ?  project xmlns= http://maven.apache.org/POM/4.0.0 \n         xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance \n         xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd \n     modelVersion 4.0.0 /modelVersion \n\n     groupId FILL ME IN/groupId \n     artifactId FILL ME IN/artifactId \n     version 1.0-SNAPSHOT /version \n\n     properties \n         maven.compiler.source 1.8 /maven.compiler.source \n         maven.compiler.target 1.8 /maven.compiler.target \n         immutables.version 2.1.11 /immutables.version \n     /properties \n\n     dependencies \n         dependency \n             groupId org.immutables /groupId \n             artifactId value /artifactId \n             version ${immutables.version} /version \n             scope provided /scope \n         /dependency \n\n         dependency \n             groupId com.github.fzakaria /groupId \n             artifactId WaterFlow /artifactId \n             version 1.0-SNAPSHOT /version \n         /dependency \n\n         dependency \n             groupId ch.qos.logback /groupId \n             artifactId logback-classic /artifactId \n             version 1.1.5 /version \n             scope runtime /scope \n         /dependency \n     /dependencies  /project  /project", 
            "title": "Setup"
        }, 
        {
            "location": "/user-guide/getting-started/#activities", 
            "text": "The bread and butter of actions in SWF are the  ActivityTasks , which represent a unit of asyncrhonous work. Activities can exist in any class that subclasses  Activities  and annotated with  ActivityMethod  public class ExampleActivities extends Activities {\n\n    @ActivityMethod(name =  Hello World , version =  1.0 )\n    public String helloWorld(String name) {\n        if (name == null) {\n            throw new IllegalArgumentException( You must provide a non null name! );\n        }\n        return String.format( Hello World %s , name);\n    }\n\n}  In the example above, we've created a very simple  ActivityTask  which given an input string, appends it to a  Hello World  message. The example above is working solely with input/output of  String  however you are not limited to that! We will see in the following documentation that thanks to the  DataConverter  we can pass arbitrary complex types to/from our Activities.", 
            "title": "Activities"
        }, 
        {
            "location": "/user-guide/getting-started/#workflow", 
            "text": "The workflow class in the framework represents the  Decider . Through the interface  public CompletionStage decide(DecisionContext decisionContext)  the Workflow can orchestrate the future actions that need to occur for the workflow given the previous history.  The example below is a simple example of implementing the Workflow interface. Each workflow has an associated name and version which is important when decided which instance the decider needs to find. As you can see in the  decide  method, orchestrating future tasks is as simple as using the JDK8 interface for  CompletionStage .  @Value.Immutable\npublic class HelloWorldWorkflow extends Workflow String,String  {\n\n    @Override\n    public Name name() {\n        return Name.of( Hello World );\n    }\n\n    @Override\n    public Version version() {\n        return Version.of( 1.0 );\n    }\n\n    @Override\n    public TypeToken String  inputType() {\n        return TypeToken.of(String.class);\n    }\n\n    @Override\n    public TypeToken String  outputType() {\n        return TypeToken.of(String.class);\n    }\n\n    @Override\n    public DataConverter dataConverter() {\n        return ImmutableJacksonDataConverter.builder().build();\n    }\n\n    final StringActivityAction step1 = StringActivityAction.builder().actionId(ActionId.of( step1 ))\n            .name(Name.of( Hello World )).version(Version.of( 1.0 )).workflow(this).build();\n\n    @Override\n    public CompletionStage decide(DecisionContext decisionContext) {\n        CompletionStage String  input = workflowInput(decisionContext.events());\n\n        return input.thenCompose(i -  step1.withInput(i).decide(decisionContext));\n\n    }\n\n    //Run me to submit this workflow!\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Config config = new Config();\n        HelloWorldWorkflow workflow = ImmutableHelloWorldWorkflow.builder()\n                .description(Description.of( Starting my first workflow! )).build();\n        config.submit(workflow,  Jane Doe );\n    }\n}  We've provided a helpful  main  method that you can launch that will submit a new instance of this workflow!", 
            "title": "Workflow"
        }, 
        {
            "location": "/user-guide/getting-started/#actors-deciders-and-activity-workers", 
            "text": "You get to decide the composition of the actors. You can scale the deciders and acivity workers seperately and arrange how each one is configured when polling a particular  TaskList  or  Domain . For the purposes of this example, we demonstrate a basic setup that initiates both  Activity Workers  and  Deciders  as separate threads on the same JVM.  public class ActivityDecisionPollerPool {\n\n    protected static final Logger log = LoggerFactory.getLogger(ActivityDecisionPollerPool.class);\n\n    private final Config config = new Config();\n\n    private final  ActivityPollerPool activityPollerPool =\n            ImmutableActivityPollerPool.builder().domain(config.domain)\n                .taskList(config.taskListName)\n                .service(new ScheduledThreadPoolExecutor(config.numberOfWorkers))\n                .swf(config.swf)\n                .dataConverter(config.dataConverter)\n                .addActivities(new HelloWorldActivities()).build();\n\n    private final  DecisionPollerPool decisionPollerPool =\n            ImmutableDecisionPollerPool.builder().domain(config.domain)\n                    .taskList(config.taskListName)\n                    .service(new ScheduledThreadPoolExecutor(config.numberOfWorkers))\n                    .swf(config.swf)\n                    .dataConverter(config.dataConverter)\n                    .workflows(Lists.newArrayList(new HelloWorldWorkflow())).build();\n\n\n    public void start() {\n        activityPollerPool.start();\n        decisionPollerPool.start();\n    }\n\n    public void stop() {\n        activityPollerPool.stop();\n        decisionPollerPool.stop();\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        ActivityDecisionPollerPool activityAndDecisionPollerPool =\n                new ActivityDecisionPollerPool();\n\n        activityAndDecisionPollerPool.start();\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                log.info( Shutting down pool and exiting. );\n                activityAndDecisionPollerPool.stop();\n            }\n        });\n        log.info( activity pollers started: );\n    }\n}  For the purposes of this demonstrates, the configuration is hard configured in a POJO. However not much is needed to change the  Config  class to something that is wired by your favourite Dependency Injection framework (i.e. Guice or Spring)  \npublic class Config {\n\n    public final Domain domain = Domain.of( swift );\n\n    public final TaskListName taskListName = SwfConstants.DEFAULT_TASK_LIST;\n\n    public final Integer numberOfWorkers = 2;\n\n    public final DataConverter dataConverter = ImmutableJacksonDataConverter.builder().build();\n\n    //SWF holds the connection for 60 seconds to see if a decision is available\n    final Duration DEFAULT_CONNECTION_TIMEOUT = Duration.ofSeconds(60);\n    final Duration DEFAULT_SOCKET_TIMEOUT = DEFAULT_CONNECTION_TIMEOUT.plusSeconds(10);\n    public final AmazonSimpleWorkflow swf =  new AmazonSimpleWorkflowClient(new DefaultAWSCredentialsProviderChain(),\n            new ClientConfiguration().withConnectionTimeout((int) DEFAULT_CONNECTION_TIMEOUT.toMillis())\n                    .withSocketTimeout((int) DEFAULT_SOCKET_TIMEOUT.toMillis()));\n\n    public WorkflowExecution submit(Workflow workflow, WorkflowId workflowId, Optional Object  input) {\n        Optional Input  inputOptional = input.map( i -  dataConverter.toData(i)).map(Input::of);\n\n        StartWorkflowExecutionRequest request =\n                WorkflowExecutionRequestBuilder.builder().domain(domain)\n                        .workflow(workflow).input(inputOptional)\n                        .taskList(taskListName).workflowId(workflowId).build();\n\n        Run run = swf.startWorkflowExecution(request);\n        return new WorkflowExecution().withWorkflowId(workflowId.value()).withRunId(run.getRunId());\n    }\n\n    public  I, O  WorkflowExecution submit(Workflow I,O  workflow, I input) {\n        WorkflowId workflowId = WorkflowId.randomUniqueWorkflowId(workflow);\n        return submit(workflow, workflowId, Optional.ofNullable(input));\n    }\n}", 
            "title": "Actors - Deciders and Activity Workers"
        }, 
        {
            "location": "/user-guide/getting-started/#verifying-the-results", 
            "text": "We can use the  aws cli  tool or the SWF dashboard to verify our results!\nScroll  down  to the bottom until you see the  WorkflowExecutionCompleted  and check out the result!  {\n   events : [\n    {\n       eventId : 1,\n       eventType :  WorkflowExecutionStarted ,\n       workflowExecutionStartedEventAttributes : {\n         taskList : {\n           name :  DEFAULT \n        },\n         parentInitiatedEventId : 0,\n         taskStartToCloseTimeout :  60 ,\n         childPolicy :  TERMINATE ,\n         executionStartToCloseTimeout :  30758400 ,\n         input :  \\ Jane Doe\\ ,\n         workflowType : {\n           version :  1.0 ,\n           name :  Hello World \n        }\n      },\n       eventTimestamp : 1456343145.567\n    },\n    {\n       eventId : 2,\n       eventType :  DecisionTaskScheduled ,\n       decisionTaskScheduledEventAttributes : {\n         startToCloseTimeout :  60 ,\n         taskList : {\n           name :  DEFAULT \n        }\n      },\n       eventTimestamp : 1456343145.567\n    },\n    {\n       eventId : 3,\n       eventType :  DecisionTaskStarted ,\n       eventTimestamp : 1456343145.654,\n       decisionTaskStartedEventAttributes : {\n         scheduledEventId : 2,\n         identity :  DECIDER-0 \n      }\n    },\n    {\n       eventId : 4,\n       eventType :  DecisionTaskTimedOut ,\n       decisionTaskTimedOutEventAttributes : {\n         startedEventId : 3,\n         timeoutType :  START_TO_CLOSE ,\n         scheduledEventId : 2\n      },\n       eventTimestamp : 1456343205.66\n    },\n    {\n       eventId : 5,\n       eventType :  DecisionTaskScheduled ,\n       decisionTaskScheduledEventAttributes : {\n         startToCloseTimeout :  60 ,\n         taskList : {\n           name :  DEFAULT \n        }\n      },\n       eventTimestamp : 1456343205.66\n    },\n    {\n       eventId : 6,\n       eventType :  DecisionTaskStarted ,\n       eventTimestamp : 1456343205.708,\n       decisionTaskStartedEventAttributes : {\n         scheduledEventId : 5,\n         identity :  DECIDER-0 \n      }\n    },\n    {\n       eventId : 7,\n       eventType :  DecisionTaskCompleted ,\n       decisionTaskCompletedEventAttributes : {\n         startedEventId : 6,\n         scheduledEventId : 5\n      },\n       eventTimestamp : 1456343206.078\n    },\n    {\n       eventId : 8,\n       eventType :  ActivityTaskScheduled ,\n       activityTaskScheduledEventAttributes : {\n         taskList : {\n           name :  DEFAULT \n        },\n         scheduleToCloseTimeout :  NONE ,\n         activityType : {\n           version :  1.0 ,\n           name :  Hello World \n        },\n         decisionTaskCompletedEventId : 7,\n         heartbeatTimeout :  NONE ,\n         activityId :  step1 ,\n         scheduleToStartTimeout :  NONE ,\n         startToCloseTimeout :  NONE ,\n         input :  [ \\ [Ljava.lang.Object;\\ , [ \\ Jane Doe\\  ] ] \n      },\n       eventTimestamp : 1456343206.078\n    },\n    {\n       eventId : 9,\n       eventType :  ActivityTaskStarted ,\n       eventTimestamp : 1456343206.185,\n       activityTaskStartedEventAttributes : {\n         scheduledEventId : 8,\n         identity :  ACTIVITY-0 \n      }\n    },\n    {\n       eventId : 10,\n       eventType :  ActivityTaskCompleted ,\n       activityTaskCompletedEventAttributes : {\n         startedEventId : 9,\n         scheduledEventId : 8,\n         result :  \\ Hello World Jane Doe!\\ \n      },\n       eventTimestamp : 1456343206.39\n    },\n    {\n       eventId : 11,\n       eventType :  DecisionTaskScheduled ,\n       decisionTaskScheduledEventAttributes : {\n         startToCloseTimeout :  60 ,\n         taskList : {\n           name :  DEFAULT \n        }\n      },\n       eventTimestamp : 1456343206.39\n    },\n    {\n       eventId : 12,\n       eventType :  DecisionTaskStarted ,\n       eventTimestamp : 1456343206.45,\n       decisionTaskStartedEventAttributes : {\n         scheduledEventId : 11,\n         identity :  DECIDER-1 \n      }\n    },\n    {\n       eventId : 13,\n       eventType :  DecisionTaskCompleted ,\n       decisionTaskCompletedEventAttributes : {\n         startedEventId : 12,\n         scheduledEventId : 11\n      },\n       eventTimestamp : 1456343206.621\n    },\n    {\n       eventId : 14,\n       eventType :  WorkflowExecutionCompleted ,\n       workflowExecutionCompletedEventAttributes : {\n         result :  \\ Hello World Jane Doe!\\ ,\n         decisionTaskCompletedEventId : 13\n      },\n       eventTimestamp : 1456343206.621\n    }\n  ]\n}", 
            "title": "Verifying The Results"
        }, 
        {
            "location": "/about/license/", 
            "text": "The MIT License (MIT)\n\n\nCopyright \u00a9 \n2016\n \nFarid Zakaria\n\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \u201cSoftware\u201d), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/about/license/#the-mit-license-mit", 
            "text": "Copyright \u00a9  2016   Farid Zakaria  Permission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \u201cSoftware\u201d), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:  The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.", 
            "title": "The MIT License (MIT)"
        }
    ]
}